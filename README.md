# Лабораторна робота №3  
## Валідація, обробка помилок, ORM

---

## Варіант

- **Група:** ІМ-33  
- `33 % 3 = 0` → **варіант: облік доходів (сутність "рахунок" / Account)** 

---

## Опис проєкту

Застосунок реалізований на **Flask** і надає REST API для обліку витрат користувачів з використанням:

- **PostgreSQL** як бази даних;
- **Flask-SQLAlchemy** як ORM;
- **Flask-Migrate** для міграцій;
- базової валідації вхідних даних та обробки помилок у ендпоінтах.

Додатково, згідно варіанту, реалізовано **облік доходів** через сутність **Account (рахунок)**:  
на рахунок можна додавати гроші, і при створенні нової витрати сума **автоматично списується з балансу**. Якщо грошей не вистачає — повертається помилка. 

---

## Мета роботи

- Покращити проєкт шляхом:
  - валідації вхідних даних,
  - обробки помилок,
  - використання ORM з реальною базою даних.
- Навчитись працювати з:
  - Flask-SQLAlchemy,
  - Flask-Migrate,
  - Docker + docker-compose для локального запуску БД.
- Реалізувати додатковий функціонал згідно варіанту — **облік доходів**.   

---

## Стек технологій

- **Python 3**
- **Flask**
- **Flask-SQLAlchemy**
- **Flask-Migrate**
- **PostgreSQL**
- **Docker**, **docker-compose**

---

## Структура основних сутностей (ORM)

Реалізовані такі моделі (через SQLAlchemy):

- **User**
  - `id` — первинний ключ
  - `name` — імʼя користувача
  - звʼязки:
    - `records` — список витрат користувача
    - `account` — один рахунок користувача (варіант 0)

- **Category**
  - `id`
  - `name` — назва категорії витрат (унікальна)
  - `records` — витрати цієї категорії

- **Record** (витрата)
  - `id`
  - `user_id` → `User`
  - `category_id` → `Category`
  - `created_at` — дата/час створення
  - `amount` — сума витрати

- **Account** (рахунок, варіант 0 — облік доходів)   
  - `id`
  - `user_id` → `User` (one-to-one)
  - `balance` — поточний баланс рахунку користувача

---

## Основні ендпоінти

### Healthcheck

- `GET /healthcheck`  
  Перевірка, що сервіс працює.

### Користувачі

- `GET /users` — список усіх користувачів  
- `GET /user/<id>` — отримати користувача  
- `POST /user` — створити користувача  
  - Body (JSON): `{ "name": "Ім'я" }`
- `DELETE /user/<id>` — видалити користувача (разом із витратами та рахунком)

### Рахунок (облік доходів, варіант 0)

- `GET /user/<id>/account`  
  - Повертає інформацію про рахунок користувача.  
  - Якщо рахунок ще не існує — створюється автоматично з балансом `0`.

- `POST /user/<id>/account/deposit`  
  Поповнення рахунку користувача.  
  - Body (JSON):  
    ```json
    {
      "amount": 500
    }
    ```
  - Сума додається до балансу рахунку.

### Категорії

- `GET /category` — список категорій  
- `POST /category` — створити категорію  
  - Body: `{ "name": "Їжа" }`
- `DELETE /category?id=<id>` — видалити категорію

### Витрати (records)

- `POST /record` — створити запис витрати  
  - Body (JSON):
    ```json
    {
      "user_id": 1,
      "category_id": 1,
      "amount": 200
    }
    ```
  - Якщо у користувача немає рахунку — він створюється з балансом `0`.
  - Якщо на рахунку недостатньо коштів — повертається помилка `Insufficient funds on account`.
  - Якщо коштів вистачає — сума списується з балансу рахунку, створюється запис витрати.

- `GET /record/<id>` — отримати одну витрату  
- `DELETE /record/<id>` — видалити витрату  
- `GET /record?user_id=...&category_id=...` — отримати список витрат з фільтрами:
  - `user_id` — фільтрація за користувачем
  - `category_id` — фільтрація за категорією  
  (мінімум один з параметрів повинен бути заданий)

---

## Валідація та обробка помилок (спрощено)

У ендпоінтах виконується базова валідація:

- перевірка обовʼязкових полів (`name`, `user_id`, `category_id`, `amount`),
- перевірка, що `amount` — число та більше нуля,
- перевірка існування `User` та `Category` перед створенням витрати,
- перевірка балансу рахунку перед списанням. :contentReference[oaicite:5]{index=5}  

У разі помилки повертається JSON формату:

```json
{ "error": "текст помилки" }

```
## Компіляція і запуск проєкту

### 1. Локальний запуск 

#### Створення та активація віртуального середовища

```
python -m venv env

.\env\Scripts\Activate.ps1

pip install -r requirements.txt

flask --app app run -h 0.0.0.0 -p 8080
```
### 2. Запуск у Docker

#### Підняти базу даних
```
docker-compose up -d db
```

#### Прогнати міграції
```
flask --app app db upgrade
```

#### Запускаєм
```
docker-compose up --build
```
